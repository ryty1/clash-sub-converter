/**
 * Clash YAML Generator - CF Workers Version (Fixed)
 */

export class ClashGenerator {
    constructor(config) {
        this.config = config;
    }

    generate(proxies, useMeta = false) {
        // ÂéªÈáçËäÇÁÇπ (Êåâ name + server + port)
        const uniqueProxies = this.deduplicateProxies(proxies);

        let yaml = `# Clash Config Generated by Subscription Converter
port: 7890
socks-port: 7891
allow-lan: false
mode: Rule
log-level: info
external-controller: 127.0.0.1:9090

dns:
  enable: true
  ipv6: false
  enhanced-mode: fake-ip
  fake-ip-range: 198.18.0.1/16
  fake-ip-filter:
    - "*.lan"
    - "*.local"
    - "time.*.com"
    - "ntp.*.com"
    - "+.pool.ntp.org"
  default-nameserver:
    - 223.5.5.5
    - 119.29.29.29
  nameserver:
    - https://dns.alidns.com/dns-query
    - https://doh.pub/dns-query
  fallback:
    - https://dns.cloudflare.com/dns-query
    - https://dns.google/dns-query
  fallback-filter:
    geoip: true
    geoip-code: CN
    ipcidr:
      - 240.0.0.0/4

proxies:
`;

        // Ê∑ªÂä†ËäÇÁÇπ
        const existingNames = new Set();
        for (const proxy of uniqueProxies) {
            yaml += this.proxyToYaml(proxy, existingNames);
        }

        // Êõ¥Êñ∞ proxyNames ‰∏∫ÊúÄÁªàÂéªÈáçÂêéÁöÑÂêçÂ≠óÔºåÁî®‰∫éÂàÜÁªÑ
        const finalProxyNames = Array.from(existingNames);
        const proxyGroups = this.generateProxyGroups(finalProxyNames);
        yaml += '\nproxy-groups:\n';
        for (const group of proxyGroups) {
            yaml += this.proxyGroupToYaml(group);
        }

        // Ê∑ªÂä†ËßÑÂàô
        yaml += '\nrules:\n';
        const rules = this.generateRulesWithProviders();
        for (const rule of rules) {
            yaml += `  - ${rule}\n`;
        }

        // Ê∑ªÂä† rule-providers
        yaml += '\nrule-providers:\n';
        yaml += this.generateRuleProvidersYaml();

        return yaml;
    }

    deduplicateProxies(proxies) {
        const seen = new Set();
        const unique = [];

        for (const proxy of proxies) {
            const key = `${proxy.name}|${proxy.server}|${proxy.port}`;
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(proxy);
            }
        }

        return unique;
    }

    proxyToYaml(proxy, existingNames) {
        const clean = this.cleanProxy(proxy);

        // Ensure unique name
        let name = clean.name;
        let counter = 1;
        while (existingNames.has(name)) {
            name = `${clean.name} ${counter}`;
            counter++;
        }
        existingNames.add(name);
        clean.name = name;

        let yaml = `  - name: "${clean.name}"\n`;
        yaml += `    type: ${clean.type}\n`;
        yaml += `    server: ${clean.server}\n`;
        yaml += `    port: ${clean.port}\n`;

        // Ê†πÊçÆÁ±ªÂûãÊ∑ªÂä†ÂÖ∂‰ªñÂ≠óÊÆµ
        if (clean.type === 'ss') {
            yaml += `    cipher: ${clean.cipher || 'auto'}\n`;
            yaml += `    password: "${clean.password}"\n`;
            if (clean.plugin) {
                yaml += `    plugin: ${clean.plugin}\n`;
                if (clean['plugin-opts']) {
                    yaml += `    plugin-opts:\n`;
                    for (const [k, v] of Object.entries(clean['plugin-opts'])) {
                        yaml += `      ${k}: ${v}\n`;
                    }
                }
            }
        } else if (clean.type === 'vmess') {
            yaml += `    uuid: ${clean.uuid}\n`;
            yaml += `    alterId: ${clean.alterId || 0}\n`;
            yaml += `    cipher: ${clean.cipher || 'auto'}\n`;
            if (clean.tls) yaml += `    tls: true\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
            if (clean['ws-opts']) {
                yaml += `    ws-opts:\n`;
                yaml += `      path: "${clean['ws-opts'].path || '/'}"\n`;
                if (clean['ws-opts'].headers?.Host) {
                    yaml += `      headers:\n        Host: ${clean['ws-opts'].headers.Host}\n`;
                }
            }
        } else if (clean.type === 'vless') {
            yaml += `    uuid: ${clean.uuid}\n`;
            if (clean.tls) yaml += `    tls: true\n`;
            if (clean.servername) yaml += `    servername: ${clean.servername}\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
            if (clean.flow) yaml += `    flow: ${clean.flow}\n`;
            if (clean['reality-opts']) {
                yaml += `    reality-opts:\n`;
                yaml += `      public-key: ${clean['reality-opts']['public-key']}\n`;
                if (clean['reality-opts']['short-id']) {
                    yaml += `      short-id: ${clean['reality-opts']['short-id']}\n`;
                }
            }
            if (clean['ws-opts']) {
                yaml += `    ws-opts:\n`;
                yaml += `      path: "${clean['ws-opts'].path || '/'}"\n`;
            }
        } else if (clean.type === 'trojan') {
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
        } else if (clean.type === 'hysteria2') {
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
        } else if (clean.type === 'tuic') {
            yaml += `    uuid: ${clean.uuid}\n`;
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
        }

        if (clean['client-fingerprint']) {
            yaml += `    client-fingerprint: ${clean['client-fingerprint']}\n`;
        }

        if (clean['skip-cert-verify']) {
            yaml += `    skip-cert-verify: true\n`;
        }

        return yaml;
    }

    proxyGroupToYaml(group) {
        let yaml = `  - name: "${group.name}"\n`;
        yaml += `    type: ${group.type}\n`;

        // ÂéªÈáç proxies
        const uniqueProxies = [...new Set(group.proxies)];
        yaml += `    proxies:\n`;
        for (const p of uniqueProxies) {
            yaml += `      - "${p}"\n`;
        }

        if (group.type === 'url-test' || group.type === 'fallback') {
            yaml += `    url: http://www.gstatic.com/generate_204\n`;
            yaml += `    interval: ${group.interval || 300}\n`;
            if (group.tolerance) yaml += `    tolerance: ${group.tolerance}\n`;
        }

        return yaml;
    }

    generateProxyGroups(proxyNames) {
        const groups = [];

        for (const g of this.config.proxyGroups) {
            const group = { name: g.name, type: g.type };

            if (g.filter) {
                try {
                    const regex = new RegExp(g.filter, 'i');
                    const matched = proxyNames.filter(n => regex.test(n));
                    // ÂéªÈáç
                    group.proxies = [...new Set(matched)];
                    if (group.proxies.length === 0) group.proxies = ['DIRECT'];
                } catch {
                    group.proxies = ['DIRECT'];
                }
            } else if (g.proxies) {
                group.proxies = g.proxies;
            } else {
                group.proxies = [...new Set(proxyNames)];
            }

            if (g.type === 'url-test' || g.type === 'fallback') {
                group.url = g.url || 'http://www.gstatic.com/generate_204';
                group.interval = g.interval || 300;
                if (g.tolerance) group.tolerance = g.tolerance;
            }

            groups.push(group);
        }

        return groups;
    }

    generateRules() {
        return [
            'GEOIP,CN,üéØ ÂÖ®ÁêÉÁõ¥Ëøû',
            'MATCH,üêü ÊºèÁΩë‰πãÈ±º'
        ];
    }

    generateRulesWithProviders() {
        const rules = [];

        for (const rs of this.config.rulesets) {
            if (rs.isBuiltin) {
                if (rs.type === 'GEOIP') {
                    rules.push(`GEOIP,${rs.value},${rs.group}`);
                }
            } else {
                const name = this.getProviderName(rs.source);
                rules.push(`RULE-SET,${name},${rs.group}`);
            }
        }

        rules.push('MATCH,üêü ÊºèÁΩë‰πãÈ±º');
        return rules;
    }

    generateRuleProvidersYaml() {
        let yaml = '';

        for (const rs of this.config.rulesets) {
            if (!rs.isBuiltin) {
                const name = this.getProviderName(rs.source);
                yaml += `  ${name}:\n`;
                yaml += `    type: http\n`;
                yaml += `    behavior: classical\n`;
                yaml += `    url: "${rs.source}"\n`;
                yaml += `    path: ./ruleset/${name}.yaml\n`;
                yaml += `    interval: 86400\n`;
            }
        }

        return yaml;
    }

    getProviderName(url) {
        const match = url.match(/\/([^\/]+?)(?:\.list|\.yaml|\.txt)?$/);
        if (match) return match[1].replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return 'provider_' + btoa(url).substring(0, 8).replace(/[=+\/]/g, '_');
    }

    cleanProxy(proxy) {
        const cleaned = {};
        for (const [key, value] of Object.entries(proxy)) {
            if (value !== undefined && value !== null) {
                cleaned[key] = value;
            }
        }
        return cleaned;
    }
}
