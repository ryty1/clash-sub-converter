/**
 * Clash YAML Generator - CF Workers Version (Fixed)
 */

export class ClashGenerator {
    constructor(config) {
        this.config = config;
    }

    generate(proxies, useMeta = false) {
        // ÂéªÈáçËäÇÁÇπ (Êåâ name + server + port)
        const uniqueProxies = this.deduplicateProxies(proxies);

        let yaml = `# Clash Config Generated by Subscription Converter
port: 7890
socks-port: 7891
allow-lan: false
mode: rule
log-level: info
geodata-mode: true
geo-auto-update: true
geodata-loader: standard
geo-update-interval: 24
geox-url:
  geoip: https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat
  geosite: https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat
  mmdb: https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/country.mmdb
  asn: https://github.com/xishang0128/geoip/releases/download/latest/GeoLite2-ASN.mmdb

dns:
  enable: true
  ipv6: true
  respect-rules: true
  enhanced-mode: fake-ip
  fake-ip-range: 198.18.0.1/16
  fake-ip-filter:
    - "*.lan"
    - "*.local"
    - "time.*.com"
    - "ntp.*.com"
    - "+.pool.ntp.org"
  nameserver:
    - https://120.53.53.53/dns-query
    - https://223.5.5.5/dns-query
  proxy-server-nameserver:
    - https://120.53.53.53/dns-query
    - https://223.5.5.5/dns-query
  nameserver-policy:
    geosite:cn,private:
      - https://120.53.53.53/dns-query
      - https://223.5.5.5/dns-query
    geosite:geolocation-!cn:
      - https://dns.cloudflare.com/dns-query
      - https://dns.google/dns-query

proxies:
`;

        // Ê∑ªÂä†ËäÇÁÇπ
        const existingNames = new Set();
        for (const proxy of uniqueProxies) {
            yaml += this.proxyToYaml(proxy, existingNames);
        }

        // Êõ¥Êñ∞ proxyNames ‰∏∫ÊúÄÁªàÂéªÈáçÂêéÁöÑÂêçÂ≠óÔºåÁî®‰∫éÂàÜÁªÑ
        const finalProxyNames = Array.from(existingNames);
        const proxyGroups = this.generateProxyGroups(finalProxyNames);
        yaml += '\nproxy-groups:\n';
        for (const group of proxyGroups) {
            yaml += this.proxyGroupToYaml(group);
        }

        // Ê∑ªÂä†ËßÑÂàô
        yaml += '\nrules:\n';
        const rules = this.generateRulesWithProviders();
        for (const rule of rules) {
            yaml += `  - ${rule}\n`;
        }

        // Ê∑ªÂä† rule-providers
        yaml += '\nrule-providers:\n';
        yaml += this.generateRuleProvidersYaml();

        return yaml;
    }

    deduplicateProxies(proxies) {
        const seen = new Set();
        const unique = [];

        for (const proxy of proxies) {
            const key = `${proxy.name}|${proxy.server}|${proxy.port}`;
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(proxy);
            }
        }

        return unique;
    }

    proxyToYaml(proxy, existingNames) {
        const clean = this.cleanProxy(proxy);

        // Ensure unique name
        let name = clean.name;
        let counter = 1;
        while (existingNames.has(name)) {
            name = `${clean.name} ${counter}`;
            counter++;
        }
        existingNames.add(name);
        clean.name = name;

        let yaml = `  - name: "${clean.name}"\n`;
        yaml += `    type: ${clean.type}\n`;
        yaml += `    server: ${clean.server}\n`;
        yaml += `    port: ${clean.port}\n`;

        // Ê†πÊçÆÁ±ªÂûãÊ∑ªÂä†ÂÖ∂‰ªñÂ≠óÊÆµ
        if (clean.type === 'ss') {
            yaml += `    cipher: ${clean.cipher || 'auto'}\n`;
            yaml += `    password: "${clean.password}"\n`;
            if (clean.plugin) {
                yaml += `    plugin: ${clean.plugin}\n`;
                if (clean['plugin-opts']) {
                    yaml += `    plugin-opts:\n`;
                    for (const [k, v] of Object.entries(clean['plugin-opts'])) {
                        yaml += `      ${k}: ${v}\n`;
                    }
                }
            }
        } else if (clean.type === 'vmess') {
            yaml += `    uuid: ${clean.uuid}\n`;
            yaml += `    alterId: ${clean.alterId || 0}\n`;
            yaml += `    cipher: ${clean.cipher || 'auto'}\n`;
            if (clean.tls) yaml += `    tls: true\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
            if (clean['ws-opts']) {
                yaml += `    ws-opts:\n`;
                yaml += `      path: "${clean['ws-opts'].path || '/'}"\n`;
                if (clean['ws-opts'].headers?.Host) {
                    yaml += `      headers:\n        Host: ${clean['ws-opts'].headers.Host}\n`;
                }
            }
        } else if (clean.type === 'vless') {
            yaml += `    uuid: ${clean.uuid}\n`;
            if (clean.tls) yaml += `    tls: true\n`;
            if (clean.servername) yaml += `    servername: ${clean.servername}\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
            if (clean.flow) yaml += `    flow: ${clean.flow}\n`;
            if (clean['reality-opts']) {
                yaml += `    reality-opts:\n`;
                yaml += `      public-key: ${clean['reality-opts']['public-key']}\n`;
                if (clean['reality-opts']['short-id']) {
                    yaml += `      short-id: ${clean['reality-opts']['short-id']}\n`;
                }
            }
            if (clean['ws-opts']) {
                yaml += `    ws-opts:\n`;
                yaml += `      path: "${clean['ws-opts'].path || '/'}"\n`;
            }
        } else if (clean.type === 'trojan') {
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
        } else if (clean.type === 'hysteria2') {
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
        } else if (clean.type === 'tuic') {
            yaml += `    uuid: ${clean.uuid}\n`;
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
        }

        if (clean['client-fingerprint']) {
            yaml += `    client-fingerprint: ${clean['client-fingerprint']}\n`;
        }

        if (clean['skip-cert-verify']) {
            yaml += `    skip-cert-verify: true\n`;
        }

        return yaml;
    }

    proxyGroupToYaml(group) {
        let yaml = `  - name: "${group.name}"\n`;
        yaml += `    type: ${group.type}\n`;

        // ÂéªÈáç proxies
        const uniqueProxies = [...new Set(group.proxies)];
        yaml += `    proxies:\n`;
        for (const p of uniqueProxies) {
            yaml += `      - "${p}"\n`;
        }

        if (group.type === 'url-test' || group.type === 'fallback') {
            yaml += `    url: http://www.gstatic.com/generate_204\n`;
            yaml += `    interval: ${group.interval || 300}\n`;
            if (group.tolerance) yaml += `    tolerance: ${group.tolerance}\n`;
        }

        return yaml;
    }

    generateProxyGroups(proxyNames) {
        const groups = [];
        const removedGroups = new Set();
        this.removedGroups = removedGroups; // Store for rules generation

        // First pass: Process groups with filters
        for (const g of this.config.proxyGroups) {
            if (g.filter) {
                const group = { name: g.name, type: g.type };
                try {
                    const regex = new RegExp(g.filter, 'i');
                    const matched = proxyNames.filter(n => regex.test(n));
                    if (matched.length === 0) {
                        removedGroups.add(g.name);
                        continue; // Skip empty filtered group
                    }
                    group.proxies = [...new Set(matched)];
                } catch {
                    removedGroups.add(g.name);
                    continue;
                }

                if (g.type === 'url-test' || g.type === 'fallback') {
                    group.url = g.url || 'http://www.gstatic.com/generate_204';
                    group.interval = g.interval || 300;
                    if (g.tolerance) group.tolerance = g.tolerance;
                }
                groups.push(group);
            }
        }

        // Second pass: Process groups without filters (manual lists)
        for (const g of this.config.proxyGroups) {
            if (!g.filter) {
                const group = { name: g.name, type: g.type };
                let proxies = g.proxies || [];

                // Filter out removed groups from the proxies list
                if (proxies.length > 0) {
                    proxies = proxies.filter(p => !removedGroups.has(p));
                }

                // If special handling needed for 'select' groups that might become empty
                // usually these have static items like 'DIRECT' or 'REJECT', so we don't need aggressive fallback
                if (proxies.length === 0) proxies = ['DIRECT'];

                group.proxies = [...new Set(proxies)]; // Deduplicate

                if (g.type === 'url-test' || g.type === 'fallback') {
                    group.url = g.url || 'http://www.gstatic.com/generate_204';
                    group.interval = g.interval || 300;
                    if (g.tolerance) group.tolerance = g.tolerance;
                }
                groups.push(group);
            }
        }

        // Sort groups to match original order logic if needed, 
        // but currently we split them. If config order matters (it usually does for UI), 
        // we might want to re-sort or process in one loop with a lookahead. 
        // But simply appending manual groups after filtered ones might change order.
        // Let's preserve order by using a map or re-iterating config.

        const finalGroups = [];
        const groupMap = new Map(groups.map(g => [g.name, g]));

        for (const g of this.config.proxyGroups) {
            if (groupMap.has(g.name)) {
                finalGroups.push(groupMap.get(g.name));
            }
        }

        return finalGroups;
    }

    generateRules() {
        return [
            'GEOIP,CN,üéØ ÂÖ®ÁêÉÁõ¥Ëøû',
            'MATCH,üêü ÊºèÁΩë‰πãÈ±º'
        ];
    }

    generateRulesWithProviders() {
        const rules = [];

        for (const rs of this.config.rulesets) {
            let group = rs.group;
            // Check if group was removed due to being empty
            if (this.removedGroups && this.removedGroups.has(group)) {
                group = 'DIRECT';
            }

            if (rs.isBuiltin) {
                if (rs.type === 'GEOIP') {
                    rules.push(`GEOIP,${rs.value},${group}`);
                }
            } else {
                const name = this.getProviderName(rs.source);
                rules.push(`RULE-SET,${name},${group}`);
            }
        }

        rules.push('MATCH,üêü ÊºèÁΩë‰πãÈ±º');
        return rules;
    }

    generateRuleProvidersYaml() {
        let yaml = '';

        for (const rs of this.config.rulesets) {
            if (!rs.isBuiltin) {
                const name = this.getProviderName(rs.source);
                yaml += `  ${name}:\n`;
                yaml += `    type: http\n`;
                yaml += `    behavior: classical\n`;
                yaml += `    url: "${rs.source}"\n`;
                yaml += `    path: ./ruleset/${name}.yaml\n`;
                yaml += `    interval: 86400\n`;
            }
        }

        return yaml;
    }

    getProviderName(url) {
        const match = url.match(/\/([^\/]+?)(?:\.list|\.yaml|\.txt)?$/);
        if (match) return match[1].replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return 'provider_' + btoa(url).substring(0, 8).replace(/[=+\/]/g, '_');
    }

    cleanProxy(proxy) {
        const cleaned = {};
        for (const [key, value] of Object.entries(proxy)) {
            if (value !== undefined && value !== null) {
                cleaned[key] = value;
            }
        }
        return cleaned;
    }
}
