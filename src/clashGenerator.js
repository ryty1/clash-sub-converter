/**
 * Clash YAML Generator - CF Workers Version (Fixed)
 */

export class ClashGenerator {
    constructor(config) {
        this.config = config;
    }

    async generate(proxies, useMeta = false) {
        // ÂéªÈáçËäÇÁÇπ (Êåâ name + server + port)
        const uniqueProxies = this.deduplicateProxies(proxies);

        let yaml = `# Clash Config Generated by Subscription Converter
port: 7890
socks-port: 7891
allow-lan: false
mode: rule
log-level: info
geodata-mode: true
geo-auto-update: true
geodata-loader: standard
geo-update-interval: 24
geox-url:
  geoip: https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat
  geosite: https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat
  mmdb: https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/country.mmdb
  asn: https://github.com/xishang0128/geoip/releases/download/latest/GeoLite2-ASN.mmdb

dns:
  enable: true
  ipv6: true
  respect-rules: true
  enhanced-mode: fake-ip
  fake-ip-range: 198.18.0.1/16
  fake-ip-filter:
    - "*.lan"
    - "*.local"
    - "time.*.com"
    - "ntp.*.com"
    - "+.pool.ntp.org"
  nameserver:
    - https://120.53.53.53/dns-query
    - https://223.5.5.5/dns-query
  proxy-server-nameserver:
    - https://120.53.53.53/dns-query
    - https://223.5.5.5/dns-query
  nameserver-policy:
    geosite:cn,private:
      - https://120.53.53.53/dns-query
      - https://223.5.5.5/dns-query
    geosite:geolocation-!cn:
      - https://dns.cloudflare.com/dns-query
      - https://dns.google/dns-query

proxies:
`;

        // Ê∑ªÂä†ËäÇÁÇπ
        const existingNames = new Set();
        for (const proxy of uniqueProxies) {
            yaml += this.proxyToYaml(proxy, existingNames);
        }

        // Êõ¥Êñ∞ proxyNames ‰∏∫ÊúÄÁªàÂéªÈáçÂêéÁöÑÂêçÂ≠óÔºåÁî®‰∫éÂàÜÁªÑ
        const finalProxyNames = Array.from(existingNames);
        const proxyGroups = this.generateProxyGroups(finalProxyNames);
        yaml += '\nproxy-groups:\n';
        for (const group of proxyGroups) {
            yaml += this.proxyGroupToYaml(group);
        }

        // Ê∑ªÂä†ÂÜÖËÅîËßÑÂàô (fetch and inline)
        yaml += '\nrules:\n';
        const inlineRules = await this.fetchInlineRules();
        for (const rule of inlineRules) {
            yaml += `  - ${rule}\n`;
        }

        return yaml;
    }

    async fetchInlineRules() {
        const allRules = [];

        // Fetch all remote rulesets in parallel
        const fetchPromises = this.config.rulesets.map(async (rs) => {
            let group = rs.group;
            if (this.removedGroups && this.removedGroups.has(group)) {
                group = 'DIRECT';
            }

            if (rs.isBuiltin) {
                // Built-in rules (GEOIP, FINAL)
                if (rs.type === 'GEOIP') {
                    return [`GEOIP,${rs.value},${group}`];
                } else if (rs.type === 'FINAL') {
                    return [`MATCH,${group}`];
                }
                return [];
            }

            // Fetch remote ruleset
            try {
                const response = await fetch(rs.source, {
                    headers: { 'User-Agent': 'ClashSubConverter/1.0' }
                });
                if (!response.ok) {
                    console.error(`Failed to fetch ruleset: ${rs.source}`);
                    return [];
                }
                const text = await response.text();
                const rules = this.parseRuleList(text, group);
                return rules;
            } catch (e) {
                console.error(`Error fetching ruleset ${rs.source}:`, e);
                return [];
            }
        });

        const results = await Promise.all(fetchPromises);
        for (const rules of results) {
            allRules.push(...rules);
        }

        return allRules;
    }

    parseRuleList(text, group) {
        const rules = [];
        const lines = text.split('\n');
        // Options that are NOT proxy groups
        const ruleOptions = ['no-resolve', 'src', 'dst'];

        for (let line of lines) {
            line = line.trim();
            // Skip empty lines and comments
            if (!line || line.startsWith('#') || line.startsWith('//') || line.startsWith(';')) {
                continue;
            }

            // Check if line already has a policy/group
            // Format: TYPE,VALUE or TYPE,VALUE,POLICY or TYPE,VALUE,POLICY,no-resolve
            const parts = line.split(',');
            if (parts.length >= 2) {
                const ruleType = parts[0].toUpperCase();
                // Supported rule types
                const supportedTypes = [
                    'DOMAIN', 'DOMAIN-SUFFIX', 'DOMAIN-KEYWORD', 'DOMAIN-REGEX',
                    'IP-CIDR', 'IP-CIDR6', 'GEOIP', 'GEOSITE',
                    'PROCESS-NAME', 'PROCESS-PATH',
                    'SRC-IP-CIDR', 'SRC-PORT', 'DST-PORT',
                    'AND', 'OR', 'NOT', 'MATCH'
                ];

                if (supportedTypes.includes(ruleType)) {
                    if (parts.length === 2) {
                        // TYPE,VALUE -> TYPE,VALUE,group
                        rules.push(`${line},${group}`);
                    } else if (parts.length === 3) {
                        // Check if third part is an option (like no-resolve) or a policy
                        const thirdPart = parts[2].trim().toLowerCase();
                        if (ruleOptions.includes(thirdPart)) {
                            // TYPE,VALUE,no-resolve -> TYPE,VALUE,group,no-resolve
                            rules.push(`${parts[0]},${parts[1]},${group},${parts[2]}`);
                        } else {
                            // TYPE,VALUE,POLICY -> use as-is
                            rules.push(line);
                        }
                    } else {
                        // 4+ parts, use as-is
                        rules.push(line);
                    }
                }
            }
        }

        return rules;
    }

    deduplicateProxies(proxies) {
        const seen = new Set();
        const unique = [];

        for (const proxy of proxies) {
            const key = `${proxy.name}|${proxy.server}|${proxy.port}`;
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(proxy);
            }
        }

        return unique;
    }

    proxyToYaml(proxy, existingNames) {
        const clean = this.cleanProxy(proxy);

        // Ensure unique name
        let name = clean.name;
        let counter = 1;
        while (existingNames.has(name)) {
            name = `${clean.name} ${counter}`;
            counter++;
        }
        existingNames.add(name);
        clean.name = name;

        let yaml = `  - name: ${clean.name}\n`;
        yaml += `    type: ${clean.type}\n`;
        yaml += `    server: ${clean.server}\n`;
        yaml += `    port: ${clean.port}\n`;

        // Ê†πÊçÆÁ±ªÂûãÊ∑ªÂä†ÂÖ∂‰ªñÂ≠óÊÆµ
        if (clean.type === 'ss') {
            yaml += `    cipher: ${clean.cipher || 'auto'}\n`;
            yaml += `    password: "${clean.password}"\n`;
            if (clean.plugin) {
                yaml += `    plugin: ${clean.plugin}\n`;
                if (clean['plugin-opts']) {
                    yaml += `    plugin-opts:\n`;
                    for (const [k, v] of Object.entries(clean['plugin-opts'])) {
                        const val = typeof v === 'boolean' || v === 'true' || v === 'false' ? v : `"${v}"`;
                        yaml += `      ${k}: ${val}\n`;
                    }
                }
            }
        } else if (clean.type === 'vmess') {
            yaml += `    uuid: ${clean.uuid}\n`;
            yaml += `    alterId: ${clean.alterId || 0}\n`;
            yaml += `    cipher: ${clean.cipher || 'auto'}\n`;
            if (clean.tls) yaml += `    tls: true\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
            if (clean['ws-opts']) {
                yaml += `    ws-opts:\n`;
                yaml += `      path: "${clean['ws-opts'].path || '/'}"\n`;
                if (clean['ws-opts'].headers?.Host) {
                    yaml += `      headers:\n        Host: ${clean['ws-opts'].headers.Host}\n`;
                }
            }
        } else if (clean.type === 'vless') {
            yaml += `    uuid: ${clean.uuid}\n`;
            if (clean.tls) yaml += `    tls: true\n`;
            // client-fingerprint ÊîæÂú® tls ÂêéÈù¢
            if (clean['client-fingerprint']) {
                yaml += `    client-fingerprint: ${clean['client-fingerprint']}\n`;
            }
            if (clean.servername) yaml += `    servername: ${clean.servername}\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
            if (clean['reality-opts']) {
                yaml += `    reality-opts:\n`;
                yaml += `      public-key: ${clean['reality-opts']['public-key']}\n`;
                if (clean['reality-opts']['short-id']) {
                    yaml += `      short-id: ${clean['reality-opts']['short-id']}\n`;
                }
            }
            if (clean['ws-opts']) {
                yaml += `    ws-opts:\n`;
                let path = clean['ws-opts'].path || '/';
                try {
                    if (path.includes('%')) path = decodeURIComponent(path);
                } catch (e) { }
                yaml += `      path: "${path}"\n`;
                if (clean['ws-opts'].headers) {
                    yaml += `      headers:\n`;
                    for (const [k, v] of Object.entries(clean['ws-opts'].headers)) {
                        yaml += `        ${k}: ${v}\n`;
                    }
                }
            }
            yaml += `    tfo: false\n`;
            yaml += `    skip-cert-verify: ${clean['skip-cert-verify'] === true}\n`;
            // flow ÊîæÂú®ÊúÄÂêé
            if (clean.flow) yaml += `    flow: ${clean.flow}\n`;
        } else if (clean.type === 'trojan') {
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
            if (clean.network) yaml += `    network: ${clean.network}\n`;
        } else if (clean.type === 'hysteria2') {
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
        } else if (clean.type === 'tuic') {
            yaml += `    uuid: ${clean.uuid}\n`;
            yaml += `    password: "${clean.password}"\n`;
            if (clean.sni) yaml += `    sni: ${clean.sni}\n`;
        }

        // client-fingerprint Â∑≤Âú®ÂêÑÁ±ªÂûã‰∏≠ÂçïÁã¨Â§ÑÁêÜ
        // Âè™‰∏∫Èùû VLESS Á±ªÂûãÊ∑ªÂä†
        if (clean.type !== 'vless' && clean['client-fingerprint']) {
            yaml += `    client-fingerprint: ${clean['client-fingerprint']}\n`;
        }

        if (clean['skip-cert-verify'] && clean.type !== 'vless') {
            yaml += `    skip-cert-verify: true\n`;
        }

        return yaml;
    }

    proxyGroupToYaml(group) {
        let yaml = `  - name: "${group.name}"\n`;
        yaml += `    type: ${group.type}\n`;

        // ÂéªÈáç proxies
        const uniqueProxies = [...new Set(group.proxies)];
        yaml += `    proxies:\n`;
        for (const p of uniqueProxies) {
            yaml += `      - "${p}"\n`;
        }

        if (group.type === 'url-test' || group.type === 'fallback' || group.type === 'load-balance') {
            yaml += `    url: http://www.gstatic.com/generate_204\n`;
            yaml += `    interval: ${group.interval || 300}\n`;
            if (group.tolerance) yaml += `    tolerance: ${group.tolerance}\n`;
            if (group.type === 'load-balance' && group.strategy) {
                yaml += `    strategy: ${group.strategy}\n`;
            }
        }

        return yaml;
    }

    generateProxyGroups(proxyNames) {
        const groups = [];
        const removedGroups = new Set();
        this.removedGroups = removedGroups; // Store for rules generation

        // First pass: Process groups with filters
        for (const g of this.config.proxyGroups) {
            if (g.filter) {
                const group = { name: g.name, type: g.type };
                try {
                    const regex = new RegExp(g.filter, 'i');
                    const matched = proxyNames.filter(n => regex.test(n));
                    if (matched.length === 0) {
                        removedGroups.add(g.name);
                        continue; // Skip empty filtered group
                    }
                    group.proxies = [...new Set(matched)];
                } catch {
                    removedGroups.add(g.name);
                    continue;
                }

                if (g.type === 'url-test' || g.type === 'fallback' || g.type === 'load-balance') {
                    group.url = g.url || 'http://www.gstatic.com/generate_204';
                    group.interval = g.interval || 300;
                    if (g.tolerance) group.tolerance = g.tolerance;
                    if (g.type === 'load-balance' && g.strategy) group.strategy = g.strategy;
                }
                groups.push(group);
            }
        }

        // Second pass: Process groups without filters (manual lists)
        for (const g of this.config.proxyGroups) {
            if (!g.filter) {
                const group = { name: g.name, type: g.type };
                let proxies = g.proxies || [];

                // Filter out removed groups from the proxies list
                if (proxies.length > 0) {
                    proxies = proxies.filter(p => !removedGroups.has(p));
                }

                // If special handling needed for 'select' groups that might become empty
                // usually these have static items like 'DIRECT' or 'REJECT', so we don't need aggressive fallback
                if (proxies.length === 0) proxies = ['DIRECT'];

                group.proxies = [...new Set(proxies)]; // Deduplicate

                if (g.type === 'url-test' || g.type === 'fallback' || g.type === 'load-balance') {
                    group.url = g.url || 'http://www.gstatic.com/generate_204';
                    group.interval = g.interval || 300;
                    if (g.tolerance) group.tolerance = g.tolerance;
                    if (g.type === 'load-balance' && g.strategy) group.strategy = g.strategy;
                }
                groups.push(group);
            }
        }

        // Sort groups to match original order logic if needed, 
        // but currently we split them. If config order matters (it usually does for UI), 
        // we might want to re-sort or process in one loop with a lookahead. 
        // But simply appending manual groups after filtered ones might change order.
        // Let's preserve order by using a map or re-iterating config.

        const finalGroups = [];
        const groupMap = new Map(groups.map(g => [g.name, g]));

        for (const g of this.config.proxyGroups) {
            if (groupMap.has(g.name)) {
                finalGroups.push(groupMap.get(g.name));
            }
        }

        return finalGroups;
    }

    generateRules() {
        return [
            'GEOIP,CN,üéØ ÂÖ®ÁêÉÁõ¥Ëøû',
            'MATCH,üêü ÊºèÁΩë‰πãÈ±º'
        ];
    }

    generateRulesWithProviders() {
        const rules = [];

        for (const rs of this.config.rulesets) {
            let group = rs.group;
            // Check if group was removed due to being empty
            if (this.removedGroups && this.removedGroups.has(group)) {
                group = 'DIRECT';
            }

            if (rs.isBuiltin) {
                if (rs.type === 'GEOIP') {
                    rules.push(`GEOIP,${rs.value},${group}`);
                }
            } else {
                const name = this.getProviderName(rs.source);
                rules.push(`RULE-SET,${name},${group}`);
            }
        }

        rules.push('MATCH,üêü ÊºèÁΩë‰πãÈ±º');
        return rules;
    }

    generateRuleProvidersYaml() {
        let yaml = '';

        for (const rs of this.config.rulesets) {
            if (!rs.isBuiltin) {
                const name = this.getProviderName(rs.source);
                yaml += `  ${name}:\n`;
                yaml += `    type: http\n`;
                yaml += `    behavior: classical\n`;
                yaml += `    url: "${rs.source}"\n`;
                yaml += `    path: ./ruleset/${name}.yaml\n`;
                yaml += `    interval: 86400\n`;
            }
        }

        return yaml;
    }

    getProviderName(url) {
        const match = url.match(/\/([^\/]+?)(?:\.list|\.yaml|\.txt)?$/);
        if (match) return match[1].replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        return 'provider_' + btoa(url).substring(0, 8).replace(/[=+\/]/g, '_');
    }

    cleanProxy(proxy) {
        const cleaned = {};
        for (const [key, value] of Object.entries(proxy)) {
            if (value !== undefined && value !== null) {
                cleaned[key] = value;
            }
        }
        return cleaned;
    }
}
